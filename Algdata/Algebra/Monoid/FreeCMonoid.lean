/-
Copyright (c) 2022 Jun Yoshida. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
-/

import Algdata.Init.LawfulLT
import Algdata.Data.List.Prop
import Algdata.Data.List.Ascending
import Algdata.Data.KVChain.Basic
import Algdata.Data.KVChain.MergeWith

/-!

# Free commutative monoids on linearly ordered bases

Given type `α` with instance `LinearLT α`, the free commutative monoid generated by `α` is represented as the set of ascending chains of `α × Nat`, which are implemented in terms of `KVChain`
The unit is the empty list, and the multiplication is defined using `KVChain.mergeWith`.

-/

universe u v

set_option autoImplicit false

/-!
## Some abbreviations
-/

@[inline]
abbrev FreeCMonoid.valType := Subtype (Nat.lt 0)

@[inline]
abbrev FreeCMonoid.valAdd : valType → valType → valType :=
  λ m n => ⟨m.val + n.val, Nat.add_lt_add m.property n.property⟩

instance : DecidableEq FreeCMonoid.valType :=
  inferInstance

instance : LinearLT FreeCMonoid.valType where
  lt := InvImage LT.lt Subtype.val
  trans h₁ h₂ := trans (r:=Nat.lt) (s:=Nat.lt) h₁ h₂
  irrefl m := Irreflective.irrefl (r:=Nat.lt) m.val
  trichot m n := Or.map Subtype.eq id $ Trichotomous.trichot (r:=Nat.lt) m.val n.val

instance : DecidableRel (α:=FreeCMonoid.valType) LT.lt :=
  inferInstanceAs (DecidableRel (α:=Subtype (Nat.lt 0)) (InvImage LT.lt Subtype.val))


/-!
## Definition
-/

--- The free commutative monoid generated by a linearly ordered type
--- @warning Alghouth it only required `LT α`, the monoid structure, which is lately defined, requires `LinearLT α`.
structure FreeCMonoid (α : Type u) [LT α] where
  vars : KVChain (r:=LT.lt (α:=α)) (β:=λ _=>FreeCMonoid.valType)
  deriving DecidableEq


namespace FreeCMonoid

variable {α : Type u}

/-!
## Basic constructions and instances
-/

protected
theorem eq [LT α] {x y : FreeCMonoid α} : x.vars = y.vars → x = y :=
  match x, y with
  | mk xvar, mk yvar => λ h => by simp at h; cases h; rfl

instance instHasOneFreeCMonoid [LT α]: OfNat (FreeCMonoid α) (nat_lit 1) where
  ofNat := ⟨KVChain.nil⟩

instance instMulFreeMonoid [LinearLT α] [DecidableRel (α:=α) LT.lt] : Mul (FreeCMonoid α) where
  mul x y := ⟨KVChain.mergeWith (λ _ a b => Option.some (valAdd a b)) x.vars y.vars⟩

-- Notation to construct monomials
-- cf. in `Prelude`:
--   infixl:65 " + "   => HAdd.hAdd
--   infixl:70 " * "   => HMul.hMul
--   infixr:80 " ^ "   => HPow.hPow
protected
def reprPrec [LT α] [Repr α] : FreeCMonoid α → Nat → Std.Format
| mk xs, prec =>
  match xs.toList with
  | [] => "1"
  | (t::ts) =>
    let f : Sigma (α:=α) (λ _=>valType) → Std.Format :=
      λ t => ite (t.2.val=1) (reprPrec t.1 70) (reprPrec t.1 80 ++ "^{" ++ t.2.val.repr ++ "}")
    (ite (prec > 70) Std.Format.paren id) $ ts.foldl (λ s t => s ++ f t) (f t)

protected
def repr [LT α] [Repr α] : FreeCMonoid α → Std.Format :=
  λ x => FreeCMonoid.reprPrec x 0

instance instReprFreeCMonoid [LT α] [Repr α] : Repr (FreeCMonoid α) where
  reprPrec := FreeCMonoid.reprPrec

protected 
def fromList [LinearLT α] [DecidableRel (α:=α) LT.lt] : List (α × Nat) → FreeCMonoid α :=
  List.foldl (λ x t => dite (t.2>0) (λ ht => ⟨x.vars.insertWith (λ _ a b => Option.some (valAdd a b)) t.1 ⟨t.2,ht⟩⟩) (λ _ => x)) 1


/-!
## Algebraic properties
-/

theorem nil_eq_one [LT α] : FreeCMonoid.mk (α:=α) KVChain.nil = 1 := rfl

@[simp]
theorem one_mul [LinearLT α] [DecidableRel (α:=α) LT.lt] : ∀ (x : FreeCMonoid α), 1 * x = x
| mk xvars => by
  dsimp [OfNat.ofNat, HMul.hMul, Mul.mul]
  rw [KVChain.nil_mergeWith]

theorem mul_one [LinearLT α] [DecidableRel (α:=α) LT.lt] : ∀ (x : FreeCMonoid α), x * 1 = x
| mk xvars => by
  dsimp [OfNat.ofNat, HMul.hMul, Mul.mul]
  rw [KVChain.mergeWith_nil]

section Commutative

variable [LinearLT α] [DecidableRel (α:=α) LT.lt]

theorem valAdd_comm (a b : valType) : valAdd a b = valAdd b a := by
  cases a; cases b; apply Subtype.eq; dsimp [valAdd]; rw [Nat.add_comm]

theorem mul_comm (x y : FreeCMonoid α) : x*y = y*x := by
  dsimp [HMul.hMul, Mul.mul]
  apply FreeCMonoid.eq; dsimp
  rw [KVChain.mergeWith_flip]
  dsimp [flip]
  apply KVChain.mergeWith_congrFun
  intros; rw [valAdd_comm]

end Commutative


/-!
# Calculus on degrees
-/

def degree [LT α] (deg : α → Nat := λ _ => 1): FreeCMonoid α → Nat
| mk vars => vars.foldl (λ d a n => d + deg a * n.val) 0

@[simp]
theorem degree_one [LT α] {deg : α → Nat}: degree deg (1 : FreeCMonoid α) = 0 := rfl

@[simp]
theorem degree_cons [LinearLT α] [DecidableRel (α:=α) LT.lt] {deg : α → Nat} (a : α) (n : valType) (xs : KVChain LT.lt (λ _ : α => valType)) (haxs : xs.boundLeft a) : degree deg {vars := xs.cons a n haxs} = deg a*n.val + degree deg {vars := xs} := by
  dsimp [degree]
  dsimp [KVChain.foldl, List.foldl]
  rw [Nat.add_comm 0]
  apply List.foldl_comm
  intros; rw [Nat.add_assoc]

section degree

variable [LinearLT α] [DecidableRel (α:=α) LT.lt] {deg : α → Nat}

theorem eq_one_of_degree_zero {xs : FreeCMonoid α} (hdeg_pos : ∀ a, deg a > 0 := by intros; simp) : xs.degree deg = 0 → xs = 1 := by
  cases xs with | mk xvars =>
  apply xvars.recOnList (motive:=λ xvars => degree deg ⟨xvars⟩ = 0 → FreeCMonoid.mk xvars = 1)
  case mk.nil => intros; rfl
  case mk.cons =>
    intro a b xvars _ _ heq0
    rw [degree_cons] at heq0
    have : deg a * b.1 > 0 := Nat.mul_pos (hdeg_pos a) b.2
    have : deg a * b.val + degree deg ⟨xvars⟩ > 0 :=
      calc
        0 < deg a * b.val := Nat.mul_pos (hdeg_pos a) b.2
        _ ≤ deg a * b.val + degree deg ⟨xvars⟩ := Nat.le_add_right _ _
    rw [heq0] at this
    cases this

theorem degree_mul [LinearLT α] [DecidableRel (α:=α) LT.lt] : ∀ (x y: FreeCMonoid α), (x*y).degree deg = x.degree deg + y.degree deg
| mk xvars, mk yvars =>
  xvars.recOnListOn
    (λ _ => by rw [nil_eq_one, one_mul, degree_one]; exact (Nat.zero_add _).symm)
    (λ x₁ x₂ xs hxs h_ind_xs yvars =>
      yvars.recOnListOn
        (by rw [nil_eq_one, mul_one, degree_one]; exact (Nat.add_zero _).symm)
        (λ y₁ y₂ ys hys h_ind_ys => by
          dsimp [HMul.hMul, Mul.mul] at *
          apply dite (x₁ < y₁) <;> intro hx₁y₁
          . rw [KVChain.cons_mergeWith_cons_rel hx₁y₁]
            rw [degree_cons x₁ x₂, degree_cons x₁ x₂]
            rw [h_ind_xs, Nat.add_assoc]
          apply dite (y₁ < x₁) <;> intro hy₁x₁
          . rw [KVChain.cons_mergeWith_cons_flip hy₁x₁]
            rw [degree_cons y₁ y₂, degree_cons y₁ y₂]
            rw [h_ind_ys]
            conv =>
              lhs; rw [←Nat.add_assoc, Nat.add_comm (deg y₁ * y₂.val), Nat.add_assoc]
          have : x₁ = y₁ := Trichotomous.eq_of_incomp ⟨hx₁y₁,hy₁x₁⟩
          cases this
          rw [KVChain.cons_mergeWith_cons_rfl]
          rw [degree_cons, degree_cons, degree_cons]
          dsimp
          rw [h_ind_xs]
          conv =>
            rhs;
            rw [
              Nat.add_assoc,
              ←Nat.add_assoc _ (deg x₁ * y₂.val),
              Nat.add_comm _ (deg x₁ * y₂.val),
              Nat.add_assoc,
              ←Nat.add_assoc,
              ←Nat.mul_add (deg x₁) x₂.val y₂.val
            ]
        )
    )
    yvars

end degree

end FreeCMonoid
